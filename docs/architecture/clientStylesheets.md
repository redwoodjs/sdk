# Supporting Client-Side Stylesheet Imports

This document outlines the architecture that enables developers to import stylesheets directly into "use client" components and have them automatically included in the final rendered HTML document.

## The Challenge: Bridging Two Paradigms

Typically, Vite uses an `index.html` file as the entry point to discover all necessary JavaScript and CSS assets for a project. However, our framework utilizes a server-rendered `Document` component, which gives developers full control over the HTML shell but bypasses Vite's standard asset discovery mechanism.

This creates a challenge: how can we support the intuitive developer experience of importing a stylesheet directly into a component, like `import './styles.css'`, when our `Document` is unaware of the CSS dependencies deep within our client-side JavaScript?

## The Solution: A Coordinated System of Vite Plugins

Our solution involves a system of two Vite plugins that work in tandem to connect the client-side module graph with the server-rendered `Document`.

### 1. [Building a Stylesheet Lookup](https://github.com/redwoodjs/sdk/blob/90679fbeee4af5cc2d026a42475432278d53ef55/sdk/src/vite/jsEntryPointsToStylesheetsPlugin.mts)

The first key component is a plugin dedicated to maintaining a lookup, or a map, between every client-side JavaScript entry point and the complete set of stylesheets it depends on.

-   **In Development**: This plugin traverses Vite's live module graph. When asked about an entry point (e.g., `/src/client.tsx`), it walks through all its imported modules, collecting every stylesheet it finds along the way. The results are cached to ensure fast performance.
-   **In Production**: For builds, the process is simpler and more efficient. The plugin reads the build manifest generated by Vite, which already contains a definitive mapping of each entry point to its final, bundled CSS files.

This lookup system effectively becomes the source of truth for which stylesheets belong to which part of the client-side application.

### 2. [Transforming the Document and Injecting Stylesheets](https://github.com/redwoodjs/sdk/blob/90679fbeee4af5cc2d026a42475432278d53ef55/sdk/src/vite/transformJsxScriptTagsPlugin.mts)

The second plugin is responsible for transforming the user's `Document` component source code.

Its job is to find all client-side JavaScript entry points. It does this by inspecting both the `src` attribute of `<script>` tags and by parsing inline scripts for dynamic `import()` calls.

It then consults the lookup system to retrieve the complete list of stylesheet URLs for all discovered entry points and dynamically modifies the `Document`'s JSX, injecting the necessary `<link rel="stylesheet" ...>` tags.

### Important Design Considerations

Several key details make this architecture robust and efficient.

#### Relying on React's Rendering Behavior

We deliberately inject the `<link>` tags into the JSX right alongside their corresponding `<script>` tag. We don't need to perform complex and brittle transformations to place them directly in the `<head>` of the Document.

This is because we rely on a standard behavior of React itself. As documented on [react.dev](https://react.dev/reference/react-dom/components/link#special-rendering-behavior), React will automatically detect `<link>` components rendered anywhere in the tree and ensure they are placed in the document's `<head>` in the final HTML. This allows our transformation logic to remain simple and robust.

#### Efficient Cache Invalidation with HMR

During development, it's crucial that this system responds instantly to changes. If a developer adds, removes, or modifies a stylesheet import, the browser should reflect that change immediately.

To achieve this, the lookup plugin hooks into Vite's Hot Module Replacement (HMR) system. When a stylesheet file is changed, the plugin doesn't naively clear its entire cache. Instead, it intelligently walks *up* the module graph from the changed file to identify only the specific JavaScript entry points that were affected. It then selectively invalidates the cache for just those entry points, ensuring minimal computation and a fast developer experience.