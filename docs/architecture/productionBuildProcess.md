# The Production Build Process

This document outlines the multi-phase build process used for production environments.

## The Challenge: Orchestrating Inter-Dependent Environments

The production build must solve several interconnected problems simultaneously, arising from the use of multiple, specialized Vite environments (`worker`, `client`, `ssr`) that have circular information dependencies:

1.  **SSR / Worker Dependency:** The `worker` environment, which is configured for React Server Components (RSC), must bundle the entire output of the `ssr` build. The `ssr` environment handles traditional server-side rendering. For a detailed explanation of how these environments interact, see the [SSR Bridge](./ssrBridge.md) architecture document. This creates a build ordering dependency: the `ssr` build must complete before the final `worker` build can begin.

2.  **Dynamic Client Entry Points:** The `client` build needs a list of all client-side JavaScript entry points (e.g., from `<script>` tags) to know what to bundle. This information is only available by traversing the application's `Document.tsx` components, which occurs during the `worker` build.

3.  **Tree-Shaking for Client Components:** The `ssr` build needs to know which `"use client"` components are actually used by the application to avoid bundling unnecessary code. This list is also only discoverable by traversing the application graph within the `worker` build.

4.  **Deferred Asset Linking:** The final `worker` bundle needs to contain the correct, hashed output paths of all client assets (e.g., `/assets/client.a1b2c3d4.js`). These paths are only known after the `client` build has run and generated its `manifest.json`.

5.  **Client Component Lookup:** The `worker` environment needs to dynamically load the SSR-processed versions of client components at runtime. This requires a lookup map—the `__client_lookup.mjs` module—that translates a component's source path to its final, bundled SSR chunk path. This map can only be generated during the `ssr` build.

These points create a deadlock. The `worker` build needs information from the `client` build (the manifest) and the `ssr` build (the bridge and lookup map bundles), but both of those builds need information discovered during the `worker` build.

## The Solution: A Phased, Sequential Build

To resolve this, we implement a five-phase sequential build process. The first three phases use Vite to build the necessary artifacts, while the final two phases are post-build filesystem operations that "stitch" the artifacts together into the final deployable worker.

### Phase 1: Worker "Discovery" Pass

The `worker` environment is built first. This is a full build pass that performs all necessary transformations on the application source code. As a crucial **side-effect** of this traversal, two key pieces of information are collected:
- A complete list of all actively used modules containing a `"use client"` directive.
- A complete list of all client-side entry points.

During this phase:
- Transformations that reference client assets (like `<script src="...">`) rewrite them into a special placeholder format (e.g., `rwsdk_asset:/src/client.tsx`).
- The import for the SSR bridge (`rwsdk/__ssr_bridge`) is marked as external, leaving a placeholder import in the final output.

The output of this phase is the `worker.js` bundle. This is a non-temporary artifact that will be modified by later phases.

### Phase 2: Client Build

With the list of entry points discovered in Phase 1, the `client` build is now executed. Its configuration is dynamically updated with this list. This build runs to completion, producing all the necessary hashed client assets and a `manifest.json` file.

### Phase 3: SSR Build

The `ssr` build runs next. Its configuration is dynamically updated with multiple entry points: the main SSR Bridge, the list of `"use client"` components discovered in Phase 1, and a virtual module for the client lookup map. This build produces the SSR bridge bundle, the client lookup map, and all the necessary SSR-processed client component chunks.

### Phase 4: SSR Artifact Injection Pass

This phase is a post-build filesystem operation. It takes the `worker.js` bundle from Phase 1 and injects the necessary SSR artifacts generated in Phase 3. It performs the following actions:
1.  Reads the content of the `worker.js` bundle from Phase 1.
2.  Reads the content of the `__ssr_bridge.js` bundle from Phase 3.
3.  Replaces the external/placeholder import for the SSR bridge in `worker.js` with the actual content of the SSR bridge bundle.
4.  Writes the modified content back to the `worker.js` file.

### Phase 5: Client Asset "Linking" Pass

This final step is also a post-build filesystem operation. It takes the `worker.js` file modified in Phase 4 and performs the final asset linking:
1.  Reads the `manifest.json` generated by the Client Build (Phase 2).
2.  Reads the content of the `worker.js` file.
3.  Performs a search-and-replace across the worker code, replacing all `rwsdk_asset:...` placeholders with their correct, final, hashed asset paths from the manifest.
4.  Writes the modified content back to the `worker.js` file, producing the final, deployable artifact.
