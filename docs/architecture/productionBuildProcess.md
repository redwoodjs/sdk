# The Production Build Process

This document outlines the multi-phase build process used for production environments.

## The Challenge: Orchestrating Inter-Dependent Environments

The production build must solve several interconnected problems simultaneously, arising from the use of multiple, specialized Vite environments (`worker`, `client`, `ssr`) that have circular information dependencies:

1.  **SSR / Worker Dependency:** The `worker` environment, which produces the final deployable Cloudflare Worker, must bundle the entire output of the `ssr` build via the `__ssr_bridge.js` module. This creates a build ordering dependency: the `ssr` build must complete before the final `worker` build can begin.

2.  **Dynamic Client Entry Points:** The `client` build needs a list of all client-side JavaScript entry points (e.g., from `<script>` tags) to know what to bundle. This information is only available by traversing the application's `Document.tsx` components, which occurs during the `worker` build.

3.  **Tree-Shaking for Client Components:** The `ssr` build needs to know which `"use client"` components are actually used by the application to avoid bundling unnecessary code. This list is also only discoverable by traversing the application graph within the `worker` build.

4.  **Deferred Asset Linking:** The final `worker` bundle needs to contain the correct, hashed output paths of all client assets (e.g., `/assets/client.a1b2c3d4.js`). These paths are only known after the `client` build has run and generated its `manifest.json`.

5.  **Client Component Lookup:** The `worker` environment needs to dynamically load the SSR-processed versions of client components at runtime. This requires a lookup map—the `__client_lookup.mjs` module—that translates a component's source path to its final, bundled SSR chunk path. This map can only be generated during the `ssr` build.

These points create a deadlock. The `worker` build needs information from the `client` build (the manifest) and the `ssr` build (the bridge and lookup map bundles), but both of those builds need information discovered during the `worker` build.

## The Solution: A Phased, Sequential Build

To resolve this, we implement a four-phase sequential build process. This approach treats discovery as a side-effect of a full, productive build pass and defers the final "linking" of assets until all necessary information has been collected.

### Phase 1: Worker "Discovery" Pass

The `worker` environment is built first. This is a full build pass that performs all necessary transformations on the application source code within the worker's module graph. As a crucial **side-effect** of this traversal, two key pieces of information are collected:
-   A complete list of all actively used modules containing a `"use client"` directive.
-   A complete list of all client-side entry points.

During this phase, transformations that reference client assets (like `<script src="...">`) do not resolve them to their final paths. Instead, they rewrite them into a special placeholder format (e.g., `rwsdk_asset:/src/client.tsx`).

### Phase 2: Client Build

With the list of entry points discovered in Phase 1, the `client` build is now executed. Its configuration is dynamically updated with this list. This build runs to completion, producing all the necessary hashed client assets and a `manifest.json` file that maps the original source paths to their final output filenames.

### Phase 3: SSR Build

The `ssr` build runs next. Its configuration is dynamically updated with multiple entry points: the main SSR Bridge, the list of `"use client"` components discovered in Phase 1, and a virtual module for the client lookup map. This build produces chunks for the SSR bridge, the client lookup map, and all the necessary SSR-processed client components in a predictable directory.

### Phase 4: Worker "Linking" and "SSR-rebundling" Pass

At this point, there are two main jobs left to complete the build:

1.  **Reprocessing of SSR Outputs:** We need to take all the outputs from the SSR build (Phase 3)—which include the `__ssr_bridge.js` bundle, the `__client_lookup.mjs` map, and all SSR-processed client component chunks—as its primary input, and re-bundle them for the Cloudflare environment.

2.  **Client Asset Linking:** At the very end of this phase, a `generateBundle` hook is used to perform the final linking step for client assets. A plugin reads the `manifest.json` generated by the Client Build (Phase 2) and performs a search-and-replace across the final worker code, replacing all `rwsdk_asset:...` placeholders with their correct, final, hashed asset paths.
