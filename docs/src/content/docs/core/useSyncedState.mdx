---
title: useSyncedState
description: A tutorial on how to use the useSyncedState hook for realtime shared state.
experimental: true
---

import { Aside } from "@astrojs/starlight/components";

`useSyncedState` looks exactly like `useState`, except it has bidirectional syncing with the server.

## What is it?

- It's a hook that synchronizes state across multiple clients (tabs, devices, users) in real-time.
- The server is the source of truth.
- It allows you to build collaborative features without needing an external realtime service.

## Why would you use it?

- **Realtime**: Updates are instant for all users on the page.
- **Native**: It's built into Redwood SDK.
- **Cloudflare**: It leverages Cloudflare Durable Objects for coordination.

## Where would you use it?

- Any component where you want data to update instantly for everyone.
- Examples: Chat apps, collaborative forms, live dashboards, presence indicators.

<Aside type="note">
  This is a low-level primitive. Currently, all values are stored in **memory** within the Durable Object.
  If the Durable Object is evicted or the worker restarts, the state is wiped.
  However, you can add callbacks to persist data to a database if needed.
</Aside>

## Tutorial: From 0 to 1

Here is the easiest way to get started.

### 1. Setup the Worker

In your `src/worker.tsx`, you need to export the `SyncedStateServer` (the Durable Object) and register its routes.

```tsx title="src/worker.tsx"
import { env } from "cloudflare:workers";
import {
  SyncedStateServer,
  syncedStateRoutes,
} from "rwsdk/use-synced-state/worker";
import { defineApp } from "rwsdk/worker";

// 1. Export the Durable Object so Cloudflare can find it
export { SyncedStateServer };

export default defineApp([
  // ... your other middleware
  // 2. Register the synced state routes
  ...syncedStateRoutes(() => env.SYNCED_STATE_SERVER),
]);
```

### 2. Update Wrangler Config

You need to tell Cloudflare about the Durable Object. Add the following to your `wrangler.jsonc`:

```jsonc title="wrangler.jsonc"
"durable_objects": {
  "bindings": [
    {
      "name": "SYNCED_STATE_SERVER",
      "class_name": "SyncedStateServer"
    }
  ]
},
"migrations": [
  {
    "tag": "v1",
    "new_sqlite_classes": ["SyncedStateServer"]
  }
]
```

> **Note**: After changing `wrangler.jsonc`, run `pnpm generate` to update your types.

### 3. Use the Hook

Now you can use `useSyncedState` in your components. It works just like `useState`, but takes a second argument: a unique key.

```tsx title="src/components/SharedCounter.tsx"
"use client";

import { useSyncedState } from "rwsdk/use-synced-state/client";

export const SharedCounter = () => {
  // "counter" is the unique key for this piece of state
  const [count, setCount] = useSyncedState(0, "counter");

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
};
```

Open this component in two different browser windows. When you click increment in one, it updates in the other instantly!

---

## Advanced: Scoping and Persistence

### Scoping State (e.g., per user or per room)

By default, the key (e.g., "counter") is global. To scope it (e.g., so each user has their own counter), you can register a key handler in your worker.

```tsx title="src/worker.tsx"
SyncedStateServer.registerKeyHandler(async (key) => {
  // Example: scope by user ID from session
  // const session = await getSession();
  // return `user:${session.userId}:${key}`;
  return key;
});
```

### Persisting State

Since the state is in-memory, you might want to save it to a database. You can register handlers for when state is set or retrieved.

```tsx title="src/worker.tsx"
SyncedStateServer.registerSetStateHandler((key, value) => {
  console.log("State updated:", key, value);
  // db.save(key, value);
});

SyncedStateServer.registerGetStateHandler((key, value) => {
   // potentially load from DB if value is undefined
});
```

## Future Plans

We are working on making this even more powerful out of the box:

- **Offline Support**: Local persistence (e.g., via IndexedDB) so your app works offline and syncs changes when the connection is restored.
- **Durable Storage**: Built-in persistence to the Durable Object's SQLite storage, ensuring state survives worker restarts without custom handlers.
